package fr.ac_versailles.crdp.apiscol.pack;

import java.io.InputStream;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;
import javax.ws.rs.Consumes;
import javax.ws.rs.DELETE;
import javax.ws.rs.DefaultValue;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.Status;
import javax.ws.rs.core.UriInfo;

import org.w3c.dom.Document;

import com.sun.jersey.multipart.FormDataParam;

import fr.ac_versailles.crdp.apiscol.ApiscolApi;
import fr.ac_versailles.crdp.apiscol.ParametersKeys;
import fr.ac_versailles.crdp.apiscol.database.DBAccessException;
import fr.ac_versailles.crdp.apiscol.packageRepresentation.ConverterFactory;
import fr.ac_versailles.crdp.apiscol.packageRepresentation.IConverter;
import fr.ac_versailles.crdp.apiscol.packageRepresentation.PackageRepresentationBuilder;
import fr.ac_versailles.crdp.apiscol.packageRepresentation.XMLResponseCreator;

@Path("/")
public class PackApi extends ApiscolApi {

	private static DAO dao;
	@Context
	UriInfo uriInfo;
	@Context
	ServletContext context;

	public PackApi(@Context ServletContext context) {
		super(context);
	}

	enum Mode {
		SCORM, IMSLD, UNKNOWN
	};

	static Mode mode;
	static String DBname = "MongoDB";
	private static String apiscolInstanceName;

	/**
	 * This methods feeds mongoDB tables in order to extract important manifest
	 * informations. The manifest is sent as an <code>inputStream</code>. Some
	 * pre-treatment are provided before connecting to the database:
	 * <ol>
	 * <li>test if this is an IMSLD file</li>
	 * <li>validation of the IMSLD file using a XSD validator</li>
	 * </ol>
	 * After that, the manifest file is definitely written on disk as a file and
	 * its contents is written in database
	 * 
	 * @param uploadedInputStream Payload of the POST request as 'file' POST parameter.
	 * @param request
	 * @return The response is the manifest representation in the specified XML format
	 * for example, here is a package representation response if no problem occurs. The package name has been automatically generated by the pack service.
	 * <br/>
	 * <code>
	 * &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;entry xmlns="http://www.w3.org/2005/Atom" xmlns:apiscol="http://www.crdp.ac-versailles.fr/2012/apiscol" xmlns:lom="http://ltsc.ieee.org/xsd/LOM" xmlns:opensearch="http://a9.com/-/spec/opensearchrss/1.0/" xmlns:svg="http://www.w3.org/2000/svg" xmlns:xhtml="http://www.w3.org/1999/xhtml"&gt;
	 * &lt;updated&gt;2013-05-15T15:45:46.000+02:00&lt;/updated&gt;
	 * &lt;id&gt;urn:apiscol:example-dev:pack:cef7d6a6-7b0e-4289-8548-ac5d2cc02cf2&lt;/id&gt;
	 * &lt;author&gt;
	 * &lt;name/&gt;
	 * &lt;/author&gt;
	 * &lt;title&gt;Les solutions aqueuses&lt;/title&gt;
	 * &lt;content type="application/xml"/&gt;
	 * &lt;link href="http://localhost:8080/pack/manifest/cef7d6a6-7b0e-4289-8548-ac5d2cc02cf2" rel="self" type="text/html"/&gt;
	 * &lt;link href="http://localhost:8080/pack/manifest/cef7d6a6-7b0e-4289-8548-ac5d2cc02cf2?format=xml" rel="self" type="application/atom+xml"/&gt;
	 * &lt;link href="http://localhost:8080/pack/manifests/cef7d6a6-7b0e-4289-8548-ac5d2cc02cf2.xml" rel="alternate" type="application/xml"/&gt;
	 * &lt;link href="http://localhost:8080/pack/manifest/cef7d6a6-7b0e-4289-8548-ac5d2cc02cf2.js" rel="alternate" type="application/javascript"/&gt;
	 * &lt;link href="http://localhost:8080/meta/148e6309-8381-4ef1-82ef-81beb4e7b50b" rel="describedby" type="application/atom+xml"/&gt;
	 * &lt;link href="http://localhost:8080/meta/lom/1/4/8/e6309-8381-4ef1-82ef-81beb4e7b50b.xml" rel="describedby" type="application/lom+xml"/&gt;
	 * &lt;/entry&gt;
	 * </code>
	 * 
	 * @throws InvalidProvidedManifestFileException
	 * @throws FileSystemAccessException
	 * @throws DBAccessException
	 * @throws IOErrorException
	 */

	@POST
	@Produces({ MediaType.APPLICATION_ATOM_XML, MediaType.APPLICATION_XML })
	@Consumes(MediaType.MULTIPART_FORM_DATA)
	public Response createPackWithPost(
			@FormDataParam("file") InputStream uploadedInputStream,
			@Context HttpServletRequest request)
			throws InvalidProvidedManifestFileException,
			FileSystemAccessException, DBAccessException, IOErrorException {
		Object response;
		String xsdPath;
		apiscolInstanceName = ApiscolApi.getProperty(
				ParametersKeys.apiscolInstanceName, context);

		PackageFile packageFile = new PackageFile(getProperty(
				ParametersKeys.fileRepoPath, context));

		if (uploadedInputStream == null) {
			return Response.status(Status.BAD_REQUEST)
					.entity("There is no uploaded file.").build();
		}
		packageFile.temporaryFileCreation();
		packageFile.writeInputStreamToFile(uploadedInputStream);
		mode = packageFile.firstAnalyse();
		switch (mode) {
		case SCORM:
			xsdPath = context.getRealPath("scorm/imscp_v1p1.xsd");
			break;

		/*
		 * case IMSLD:
		 * xsdPath=context.getRealPath("xsddocs/IMS_LD_LEVEL_A.xsd");
		 * System.out.println("xsdPath="+xsdPath); break;
		 */
		default:
			xsdPath = context.getRealPath("scorm/imscp_v1p1.xsd");

		}
		packageFile.setXsdPath(xsdPath);
		if (!PackApi.mode.equals(Mode.IMSLD)) {
			// TODO A revoir ici. PB pour la validation imscp puis ld. Pour
			// l'instant le mode est scorm
			// System.out.println("validation SCORM pour le moment...");
			packageFile.validateFile();
		}

		packageFile.renameTempFile();
		// File f = new File(packageFile.getFileValidated().getAbsolutePath());
		XMLReader xmlReader = new XMLReader(packageFile, getDao(), uriInfo);
		response = xmlReader.packageReaderAndDataBaseWriter();
		// response =
		// XMLReader.packageReader(PackageFileUtils.getFileValidated(),
		// getDao(), uriInfo);
		return Response.ok(response, MediaType.APPLICATION_XML_TYPE)
				.entity(response).build();

	}

	/*
	 * private static void setFilePath(String xsdPath) {
	 * PackageFile.setXsdPath(xsdPath); }
	 */

	/**
	 * this method is used to display package(s) representation depending of the
	 * parameters. If start and row query parameters are blank the first ten
	 * package are listed (default value).
	 * 
	 * @param request
	 * @param resIdQuery
	 *            filter parameter that allow to display all package containing
	 *            the specified resource
	 * @param format
	 * @param start
	 *            First result to display (pagination).
	 * @param rows
	 *            Number of rows to display (pagination).
	 * @param desc
	 *            If true, the package resources are listed. If false (default
	 *            value), the package resources are not listed.
	 * @return The response consists in package(s) representation depending of the parameters in the
	 *         specified XML format. <br/>
	 *         In the response, the <code>count</code> information gives the number of existing packages.
	 *         Here is an example of package representation returned if the
	 *         request is: <code>http://localhost:8080/pack/manifest?start=10&rows=2</code> <br/>
	 *         <code>
	 * &lt;?xml version="1.0" encoding="UTF-8"?&gt;
	 * &lt;xmlns="http://www.w3.org/2005/Atom" xmlns:apiscol="http://www.crdp.ac-versailles.fr/2012/apiscol" xmlns:lom="http://ltsc.ieee.org/xsd/LOM" xmlns:opensearch="http://a9.com/-/spec/opensearchrss/1.0/" xmlns:svg="http://www.w3.org/2000/svg" xmlns:xhtml="http://www.w3.org/1999/xhtml"&gt;
	 * &lt;count&gt;16&lt;/count&gt;
	 * &lt;entry&gt;
	 * &lt;updated&gt;2013-05-15T15:45:46.000+02:00&lt;/updated&gt;
	 * &lt;id&gt;urn:apiscol:example-dev:pack:cef7d6a6-7b0e-4289-8548-ac5d2cc02cf2&lt;/id&gt;
	 * &lt;author&gt;&lt;name/&gt;&lt;/author&gt;&lt;title&gt;Les solutions aqueuses&lt;/title&gt;
	 * &lt;content type="application/xml"/&gt;
	 * &lt;link href="http://localhost:8080/pack/manifest/cef7d6a6-7b0e-4289-8548-ac5d2cc02cf2" rel="self" type="text/html"/&gt;
	 * &lt;link href="http://localhost:8080/pack/manifest/cef7d6a6-7b0e-4289-8548-ac5d2cc02cf2?format=xml" rel="self" type="application/atom+xml"/&gt;
	 * &lt;link href="http://localhost:8080/pack/manifests/cef7d6a6-7b0e-4289-8548-ac5d2cc02cf2.xml" rel="alternate" type="application/xml"/&gt;
	 * &lt;link href="http://localhost:8080/pack/manifest/cef7d6a6-7b0e-4289-8548-ac5d2cc02cf2.js" rel="alternate" type="application/javascript"/&gt;
	 * &lt;link href="http://localhost:8080/meta/148e6309-8381-4ef1-82ef-81beb4e7b50b" rel="describedby" type="application/atom+xml"/&gt;
	 * &lt;link href="http://localhost:8080/meta/lom/1/4/8/e6309-8381-4ef1-82ef-81beb4e7b50b.xml" rel="describedby" type="application/lom+xml"/&gt;
	 * &lt;/entry&gt;
	 * &lt;entry&gt;
	 * &lt;updated&gt;2013-05-15T15:45:22.000+02:00&lt;/updated&gt;
	 * &lt;id&gt;urn:apiscol:example-dev:pack:1012b4d4-3824-4f7e-9bd2-fb7c5cfcb07c&lt;/id&gt;
	 * &lt;author&gt;&lt;name/&gt;&lt;/author&gt;
	 * &lt;title&gt;La constitution de la matière&lt;/title&gt;
	 * &lt;content type="application/xml"/&gt;
	 * &lt;link href="http://localhost:8080/pack/manifest/1012b4d4-3824-4f7e-9bd2-fb7c5cfcb07c" rel="self" type="text/html"/&gt;
	 * &lt;link href="http://localhost:8080/pack/manifest/1012b4d4-3824-4f7e-9bd2-fb7c5cfcb07c?format=xml" rel="self" type="application/atom+xml"/&gt;
	 * &lt;link href="http://localhost:8080/pack/manifests/1012b4d4-3824-4f7e-9bd2-fb7c5cfcb07c.xml" rel="alternate" type="application/xml"/&gt;
	 * &lt;link href="http://localhost:8080/pack/manifest/1012b4d4-3824-4f7e-9bd2-fb7c5cfcb07c.js" rel="alternate" type="application/javascript"/&gt;
	 * &lt;link href="http://localhost:8080/meta/148e6309-8381-4ef1-82ef-81beb4e7b50b" rel="describedby" type="application/atom+xml"/&gt;
	 * &lt;link href="http://localhost:8080/meta/lom/1/4/8/e6309-8381-4ef1-82ef-81beb4e7b50b.xml" rel="describedby" type="application/lom+xml"/&gt;
	 * &lt;/entry&gt;
	 * </code>
	 * @throws DBAccessException
	 */

	@GET
	@Path("/manifest")
	@Produces({ MediaType.APPLICATION_ATOM_XML, MediaType.APPLICATION_XML })
	@Consumes(MediaType.MULTIPART_FORM_DATA)
	public Response manifestList(@Context HttpServletRequest request,
			@QueryParam(value = "resid") final String resIdQuery,

			@QueryParam(value = "format") final String format,
			@DefaultValue("0") @QueryParam(value = "start") final int start,
			@DefaultValue("10") @QueryParam(value = "rows") final int rows,
			@DefaultValue("false") @QueryParam(value = "desc") boolean desc)
			throws DBAccessException {
		apiscolInstanceName = ApiscolApi.getProperty(
				ParametersKeys.apiscolInstanceName, context);
		String requestedFormat = guessRequestedFormat(request, format);
		if (requestedFormat.contains(MediaType.APPLICATION_XHTML_XML)
				|| requestedFormat.contains(MediaType.TEXT_HTML))
			desc = true;
		Object result;
		if (resIdQuery == null) {// renvoi de toute la liste des manifests
			result = getDao().readInDbResources(start, rows, desc, uriInfo);
			
		} else
			result = getDao().readInDbResources(resIdQuery);

		// TODO ces 2 conditions sont à revoir...normalement ici on a tjs resIdQuery==null
		if (requestedFormat.contains(MediaType.APPLICATION_XHTML_XML)
				|| requestedFormat.contains(MediaType.TEXT_HTML)) {
			IConverter<?> htmlResponseConverter = ConverterFactory
					.getConverter((Document) result,
							MediaType.APPLICATION_XHTML_XML,
							context.getRealPath(""));
			return Response.ok(htmlResponseConverter.convert(),
					MediaType.TEXT_HTML).build();
		}
		
		return Response.ok(result).type(MediaType.APPLICATION_XML_TYPE).build();
	}

	/**
	 * This method allows to display a package thanks to its manifest id.
	 * 
	 * @param request
	 * @param manifestIdQuery
	 *            the manifest id of the package that has to be displayed
	 * @param desc
	 *            if true, the package resources are displayed
	 * @return the package representation of the requested package in an XML
	 *         format. <br/>
	 *         Here is an example of package representation returned if the
	 *         request is:
	 *         <code>http://localhost:8080/pack/manifest/cef7d6a6-7b0e-4289-8548-ac5d2cc02cf2</code>
	 * <br/>
	 *         <code>
	 * &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;entry xmlns="http://www.w3.org/2005/Atom" xmlns:apiscol="http://www.crdp.ac-versailles.fr/2012/apiscol" xmlns:lom="http://ltsc.ieee.org/xsd/LOM" xmlns:opensearch="http://a9.com/-/spec/opensearchrss/1.0/" xmlns:svg="http://www.w3.org/2000/svg" xmlns:xhtml="http://www.w3.org/1999/xhtml"&gt;
	 * &lt;updated&gt;2013-05-15T15:45:46.000+02:00&lt;/updated&gt;
	 * &lt;id&gt;urn:apiscol:example-dev:pack:cef7d6a6-7b0e-4289-8548-ac5d2cc02cf2&lt;/id&gt;
	 * &lt;author&gt;
	 * &lt;name/&gt;
	 * &lt;/author&gt;
	 * &lt;title&gt;Les solutions aqueuses&lt;/title&gt;
	 * &lt;content type="application/xml"/&gt;
	 * &lt;link href="http://localhost:8080/pack/manifest/cef7d6a6-7b0e-4289-8548-ac5d2cc02cf2" rel="self" type="text/html"/&gt;
	 * &lt;link href="http://localhost:8080/pack/manifest/cef7d6a6-7b0e-4289-8548-ac5d2cc02cf2?format=xml" rel="self" type="application/atom+xml"/&gt;
	 * &lt;link href="http://localhost:8080/pack/manifests/cef7d6a6-7b0e-4289-8548-ac5d2cc02cf2.xml" rel="alternate" type="application/xml"/&gt;
	 * &lt;link href="http://localhost:8080/pack/manifest/cef7d6a6-7b0e-4289-8548-ac5d2cc02cf2.js" rel="alternate" type="application/javascript"/&gt;
	 * &lt;link href="http://localhost:8080/meta/148e6309-8381-4ef1-82ef-81beb4e7b50b" rel="describedby" type="application/atom+xml"/&gt;
	 * &lt;link href="http://localhost:8080/meta/lom/1/4/8/e6309-8381-4ef1-82ef-81beb4e7b50b.xml" rel="describedby" type="application/lom+xml"/&gt;
	 * &lt;/entry&gt;
	 * </code>
	 * <br/>
	 * Adding <code>desc=true</code> gives more details.</br>
	 * For example, the request <code>http://localhost:8080/pack/manifest/cef7d6a6-7b0e-4289-8548-ac5d2cc02cf2?desc=true</code> will return:
	 * <code>
	 * &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;entry xmlns="http://www.w3.org/2005/Atom" xmlns:apiscol="http://www.crdp.ac-versailles.fr/2012/apiscol" xmlns:lom="http://ltsc.ieee.org/xsd/LOM" xmlns:opensearch="http://a9.com/-/spec/opensearchrss/1.0/" xmlns:svg="http://www.w3.org/2000/svg" xmlns:xhtml="http://www.w3.org/1999/xhtml"&gt;
	 * &lt;updated&gt;2013-05-15T15:45:46.000+02:00&lt;/updated&gt;
	 * &lt;id&gt;urn:apiscol:example-dev:pack:cef7d6a6-7b0e-4289-8548-ac5d2cc02cf2&lt;/id&gt;
	 * &lt;author&gt;
	 * &lt;name/&gt;
	 * &lt;/author&gt;
	 * &lt;title&gt;Les solutions aqueuses&lt;/title&gt;
	 * &lt;content type="application/xml"&gt;
	 * &lt;apiscol:resources&gt;
	 * &lt;apiscol:resource href="http://localhost:8080/content/resource/22da186a-b84d-4f29-8713-e4d406a26300"/&gt;
	 * &lt;apiscol:resource href="http://localhost:8080/content/resource/ff4533dc-7576-41c6-b3c9-b75b34467779"/&gt;
	 * &lt;apiscol:resource href="http://localhost:8080/content/resource/71b53b81-fd2f-41ec-a845-eb06e12fc331"/&gt;
	 * &lt;apiscol:resource href="http://localhost:8080/content/resource/2d8ae54a-5402-490f-bba7-a816b9dd1f15"/&gt;
	 * &lt;apiscol:resource href="http://localhost:8080/content/resource/73a9e544-342b-4ea2-b6fa-95d97bc55052"/&gt;
	 * &lt;apiscol:resource href="http://localhost:8080/content/resource/71fc26c4-75fd-491d-b28d-494a4aabe710"/&gt;
	 * &lt;apiscol:resource href="http://localhost:8080/content/resource/c35fa79c-fa72-489e-8b20-16724002355e"/&gt;
	 * &lt;apiscol:resource href="http://localhost:8080/content/resource/583fdd6b-8583-4a9a-a3e3-01e2e9ee56bc"/&gt;
	 * &lt;apiscol:resource href="http://localhost:8080/content/resource/25b61ccf-8ffd-4c63-865b-5a51585cd329"/&gt;
	 * &lt;apiscol:resource href="http://localhost:8080/content/resource/d4978a02-3a09-48e2-9615-006811214cc4"/&gt;
	 * &lt;apiscol:resource href="http://localhost:8080/content/resource/b49f2dd9-116d-4d31-ac50-53307e30720d"/&gt;
	 * &lt;apiscol:resource href="http://localhost:8080/content/resource/8eca9ef7-f24e-4aa8-9c06-94cc26f2846d"/&gt;
	 * &lt;apiscol:resource href="http://localhost:8080/content/resource/8fb6a669-39a0-498a-b129-242e4cd3af96"/&gt;
	 * &lt;apiscol:resource href="http://localhost:8080/content/resource/f1f80d47-5faa-44b5-bf48-85d1a194a57d"/&gt;
	 * &lt;apiscol:resource href="http://localhost:8080/content/resource/cf354621-c1f6-488d-90e2-e3062566d737"/&gt;
	 * &lt;apiscol:resource href="http://localhost:8080/content/resource/7c82ac28-5fd5-4e7d-bc57-100fd61b47ca"/&gt;
	 * &lt;apiscol:resource href="http://localhost:8080/content/resource/3f5c3ebd-6682-4a86-afa8-ae4b298bb392"/&gt;
	 * &lt;apiscol:resource href="http://localhost:8080/content/resource/3f8a4614-68f3-4681-947a-435ee4695486"/&gt;
	 * &lt;apiscol:resource href="http://localhost:8080/content/resource/13fc4615-734c-489f-985f-18024699ddc4"/&gt;
	 * &lt;apiscol:resource href="http://localhost:8080/content/resource/cabb828e-a0ff-4e1c-ae32-35b8a256bfdc"/&gt;
	 * &lt;apiscol:resource href="http://localhost:8080/content/resource/be0b4d14-a66d-4cb9-b632-e3fea00bb3da"/&gt;
	 * &lt;apiscol:resource href="http://localhost:8080/content/resource/0b9577b2-b989-474f-b226-6f00869af34e"/&gt;
	 * &lt;apiscol:resource href="http://localhost:8080/content/resource/3bf51c2e-b68d-46b5-bde0-77586425370d"/&gt;
	 * &lt;apiscol:resource href="http://localhost:8080/content/resource/97456e06-5909-4586-a4f2-835d31399245"/&gt;
	 * &lt;apiscol:resource href="http://localhost:8080/content/resource/503b2494-f104-4963-b5e9-e08bcc3e027c"/&gt;
	 * &lt;apiscol:resource href="http://localhost:8080/content/resource/f3825882-3b5d-48a5-8061-0346bdec926c"/&gt;
	 * &lt;apiscol:resource href="http://localhost:8080/content/resource/7fed92d8-201d-4f26-bd1b-de818962e387"/&gt;
	 * &lt;apiscol:resource href="http://localhost:8080/content/resource/64d2d12c-d825-4dfd-9a47-23e553e5c61b"/&gt;
	 * &lt;/apiscol:resources&gt;
	 * &lt;link href="http://localhost:8080/pack/manifest/cef7d6a6-7b0e-4289-8548-ac5d2cc02cf2" rel="self" type="text/html"/&gt;
	 * &lt;link href="http://localhost:8080/pack/manifest/cef7d6a6-7b0e-4289-8548-ac5d2cc02cf2?format=xml" rel="self" type="application/atom+xml"/&gt;
	 * &lt;link href="http://localhost:8080/pack/manifests/cef7d6a6-7b0e-4289-8548-ac5d2cc02cf2.xml" rel="alternate" type="application/xml"/&gt;
	 * &lt;link href="http://localhost:8080/pack/manifest/cef7d6a6-7b0e-4289-8548-ac5d2cc02cf2.js" rel="alternate" type="application/javascript"/&gt;
	 * &lt;link href="http://localhost:8080/meta/148e6309-8381-4ef1-82ef-81beb4e7b50b" rel="describedby" type="application/atom+xml"/&gt;
	 * &lt;link href="http://localhost:8080/meta/lom/1/4/8/e6309-8381-4ef1-82ef-81beb4e7b50b.xml" rel="describedby" type="application/lom+xml"/&gt;
	 * &lt;/entry&gt;
	 * </code>
	 * @throws DBAccessException
	 * @throws NoPackageFoundException
	 */
	@GET
	@Path("/manifest/{manifestid}")
	@Produces({ MediaType.APPLICATION_ATOM_XML, MediaType.APPLICATION_XML })
	@Consumes(MediaType.MULTIPART_FORM_DATA)
	public Response manifestId(
			@Context HttpServletRequest request,
			@PathParam(value = "manifestid") final String manifestIdQuery,
			@DefaultValue("false") @QueryParam(value = "desc") final boolean desc)
			throws DBAccessException, NoPackageFoundException {
		apiscolInstanceName = ApiscolApi.getProperty(
				ParametersKeys.apiscolInstanceName, context);
		Object result;
		MongoDAO dao = (MongoDAO) getDao();
		if (manifestIdQuery == null) {
			return Response
					.status(Status.BAD_REQUEST)
					.entity("you must precise a manifest Id for this request...")
					.build();
		} else if (dao.packageExists(manifestIdQuery)) {
			// TODO: pour enlever le cast, c'est simple: ajouter dans
			// l'interface DAO les memes méthodes que MongoDAO
			PackageRepresentationBuilder prb = new PackageRepresentationBuilder(
					(MongoDAO) getDao());
			result = prb.packageRepresentation(manifestIdQuery, desc, uriInfo);
			return Response.ok(result, MediaType.APPLICATION_XML_TYPE).build();
		} else
			throw new NoPackageFoundException(manifestIdQuery);
	}

	/**
	 * Update the database using the new manifest that replace the old one. The
	 * name of the manifest that has to be updated is given in parameter.
	 * 
	 * @param request
	 * @param uploadedInputStream
	 * @param manifestIdQuery
	 * @return The response is the new updated representation of the package in the XML
	 *         specified format
	 * @throws DBAccessException
	 * @throws NoPackageFoundException
	 * @throws InvalidProvidedManifestFileException
	 * @throws FileSystemAccessException
	 * @throws IOErrorException
	 */

	@PUT
	@Path("/manifest/{manifestid}")
	@Produces({ MediaType.APPLICATION_ATOM_XML, MediaType.APPLICATION_XML })
	@Consumes(MediaType.MULTIPART_FORM_DATA)
	public Response putManifest(@Context HttpServletRequest request,
			@FormDataParam("file") InputStream uploadedInputStream,
			@PathParam(value = "manifestid") final String manifestIdQuery)
			throws DBAccessException, NoPackageFoundException,
			InvalidProvidedManifestFileException, FileSystemAccessException,
			IOErrorException {
		apiscolInstanceName = ApiscolApi.getProperty(
				ParametersKeys.apiscolInstanceName, context);
		Object response;
		String xsdPath;
		try {
			MongoDAO dao = (MongoDAO) getDao();
		} catch (DBAccessException e) {
			return Response.status(Status.SERVICE_UNAVAILABLE)
					.entity("Error: Data base access impossible").build();
		}
		PackageFile packageFile = new PackageFile(getProperty(
				ParametersKeys.fileRepoPath, context));
		if (uploadedInputStream == null) {
			return Response.status(Status.BAD_REQUEST)
					.entity("There is no uploaded file.").build();
		}
		packageFile.temporaryFileCreation();
		packageFile.writeInputStreamToFile(uploadedInputStream);
		mode = packageFile.firstAnalyse();
		logger.info("****MODE=" + mode);
		switch (mode) {
		case SCORM:
			xsdPath = context.getRealPath("scorm/imscp_v1p1.xsd");
			break;

		case IMSLD:
			xsdPath = context.getRealPath("xsddocs/imscp_v1p1.xsd");
			break;

		default:
			xsdPath = context.getRealPath("scorm/imscp_v1p1.xsd");

		}
		packageFile.setXsdPath(xsdPath);
		if (PackApi.mode.equals(Mode.IMSLD)) {
			// TODO A revoir ici. PB pour la validation imscp puis ld. Pour
			// l'instant le mode est scorm
			try {
				packageFile.validateFile();
				logger.info("***package valide***"
						+ packageFile.getFileValidated());
			} catch (InvalidProvidedManifestFileException e) {
				logger.error("package invalide: "
						+ packageFile.getTempFile());
			}
		}
		dao.removePackageInDataBase(manifestIdQuery);
		XMLResponseCreator rc;
		if (packageFile.updatePackageFromTempFile(manifestIdQuery)) {
			XMLReader xmlReader = new XMLReader(packageFile, getDao(), uriInfo);
			response = xmlReader.packageReaderAndDataBaseWriter();
			logger.info("base mise a jour pour " + manifestIdQuery);
			return Response.ok(response, MediaType.APPLICATION_XML_TYPE)
					.entity(response).build();
		} else
			rc = new XMLResponseCreator();
		response = rc.generateXMLResponse("impossible to update this package.");
		return Response.status(Status.NOT_MODIFIED).entity(response).build();
	}

	/**
	 * Delete the specified manifest on the disk and all its entry in the
	 * database.
	 * 
	 * @param request
	 * @param manifestIdQuery
	 *            the manifest name that has to be deleted.
	 * @return The response is a system message explaining if the deletion is successful or not.
	 * Here is an example of the returned message if the deteletion is going to it's end:
	 * <code>
	 * &lt;message&gt;
	 * the package 0cef8-5269-4cbf-a4a4-b27616a5fa4c has been deleted successfully
	 * &lt;/message&gt;
	 * </code>
	 */

	@DELETE
	@Path("/manifest/{manifestid}")
	@Produces({ MediaType.APPLICATION_XML, MediaType.APPLICATION_ATOM_XML })
	public Response deletePackage(@Context HttpServletRequest request,
			@PathParam(value = "manifestid") final String manifestIdQuery) {
		if (manifestIdQuery == null) {
			logger.warn("a manifest id must be precised for this request.");
			return Response
					.status(Status.BAD_REQUEST)
					.entity("you must precise a manifest Id for this request...")
					.build();
		}
		try {
			MongoDAO dao = (MongoDAO) getDao();
		} catch (DBAccessException e) {
			logger.error("No data base acces. Impossible to delete anything");
			return Response
					.status(Status.SERVICE_UNAVAILABLE)
					.entity("Error: No data base access. Impossible to delete anything")
					.build();
		}
		if (!dao.packageExists(manifestIdQuery)) {
			logger.error("No such manifest " + manifestIdQuery);
			return Response.status(Status.NOT_FOUND)
					.entity("Error: No such manifest.").build();
		}
		PackageFile packageFile = new PackageFile(getProperty(
				ParametersKeys.fileRepoPath, context));
		packageFile.removeFile(manifestIdQuery);
		dao.removePackageInDataBase(manifestIdQuery);
		XMLResponseCreator rc = new XMLResponseCreator();
		logger.info("the package " + manifestIdQuery
				+ " has been deleted successfully");
		Object response = rc
				.generateXMLResponse("the package has been deleted successfully");
		return Response.ok(response, MediaType.APPLICATION_XML_TYPE)
				.entity(response).build();
	}

	private DAO getDao() throws DBAccessException {
		if (dao == null)
			dao = DAOFactory.getDAO(DBname);
		return dao;
	}

	public static String getApiscolInstanceName() {
		return apiscolInstanceName;
	}

	public static void disconnectDb() {
		if (dao != null)
			dao.disconnect();
	}
}